{"version":3,"file":"index.js","mappings":"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","sources":["webpack://xterm-pty/webpack/universalModuleDefinition","webpack://xterm-pty/./out/index.js","webpack://xterm-pty/./src/eventEmitter.ts","webpack://xterm-pty/./src/utils.ts","webpack://xterm-pty/./src/termios.ts","webpack://xterm-pty/./src/lineDiscipline.ts","webpack://xterm-pty/./src/pty.ts","webpack://xterm-pty/./src/client-server/termiosData.ts","webpack://xterm-pty/./src/client-server/ttyClient.ts","webpack://xterm-pty/./src/client-server/ttyServer.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});// src/eventEmitter.ts\nvar EventEmitter = class {\n  constructor() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.register = this._register.bind(this);\n  }\n  _register(listener) {\n    this.listeners.add(listener);\n    return {\n      dispose: () => {\n        this.listeners.delete(listener);\n      }\n    };\n  }\n  fire(arg) {\n    for (const listener of this.listeners) {\n      try {\n        listener(arg);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }\n};\n\n// src/utils.ts\nvar BS = 8;\nvar TAB = 9;\nvar NL = 10;\nvar CR = 13;\nvar SP = 32;\nvar isalnum = (c) => 48 <= c && c <= 57 || 65 <= c && c <= 90 || c == 95 || 97 <= c && c <= 122;\nvar iscntrl = (c) => 0 <= c && c <= 31 && c != 9 || c == 127;\nvar isUtf8ContinuationByte = (c) => (c & 192) == 128;\nvar tolower = (c) => 65 <= c && c <= 90 ? c + 32 : c;\nvar toupper = (c) => 97 <= c && c <= 122 ? c - 32 : c;\nvar utf8Encoder = new TextEncoder();\nvar stringToUtf8Bytes = (str) => Array.from(utf8Encoder.encode(str));\n\n// src/termios.ts\nvar Flags = /* @__PURE__ */ ((Flags2) => {\n  Flags2[Flags2[\"ISTRIP\"] = 32] = \"ISTRIP\";\n  Flags2[Flags2[\"INLCR\"] = 64] = \"INLCR\";\n  Flags2[Flags2[\"IGNCR\"] = 128] = \"IGNCR\";\n  Flags2[Flags2[\"ICRNL\"] = 256] = \"ICRNL\";\n  Flags2[Flags2[\"IUCLC\"] = 512] = \"IUCLC\";\n  Flags2[Flags2[\"IXON\"] = 1024] = \"IXON\";\n  Flags2[Flags2[\"IXANY\"] = 2048] = \"IXANY\";\n  Flags2[Flags2[\"IMAXBEL\"] = 8192] = \"IMAXBEL\";\n  Flags2[Flags2[\"IUTF8\"] = 16384] = \"IUTF8\";\n  Flags2[Flags2[\"OPOST\"] = 1] = \"OPOST\";\n  Flags2[Flags2[\"OLCUC\"] = 2] = \"OLCUC\";\n  Flags2[Flags2[\"ONLCR\"] = 4] = \"ONLCR\";\n  Flags2[Flags2[\"OCRNL\"] = 8] = \"OCRNL\";\n  Flags2[Flags2[\"ONOCR\"] = 16] = \"ONOCR\";\n  Flags2[Flags2[\"ONLRET\"] = 32] = \"ONLRET\";\n  Flags2[Flags2[\"TABDLY\"] = 6144] = \"TABDLY\";\n  Flags2[Flags2[\"XTABS\"] = 6144] = \"XTABS\";\n  Flags2[Flags2[\"ISIG\"] = 1] = \"ISIG\";\n  Flags2[Flags2[\"ICANON\"] = 2] = \"ICANON\";\n  Flags2[Flags2[\"ECHO\"] = 8] = \"ECHO\";\n  Flags2[Flags2[\"ECHOE\"] = 16] = \"ECHOE\";\n  Flags2[Flags2[\"ECHOK\"] = 32] = \"ECHOK\";\n  Flags2[Flags2[\"ECHONL\"] = 64] = \"ECHONL\";\n  Flags2[Flags2[\"NOFLSH\"] = 128] = \"NOFLSH\";\n  Flags2[Flags2[\"ECHOCTL\"] = 512] = \"ECHOCTL\";\n  Flags2[Flags2[\"ECHOPRT\"] = 1024] = \"ECHOPRT\";\n  Flags2[Flags2[\"ECHOKE\"] = 2048] = \"ECHOKE\";\n  Flags2[Flags2[\"IEXTEN\"] = 32768] = \"IEXTEN\";\n  Flags2[Flags2[\"VINTR\"] = 0] = \"VINTR\";\n  Flags2[Flags2[\"VQUIT\"] = 1] = \"VQUIT\";\n  Flags2[Flags2[\"VERASE\"] = 2] = \"VERASE\";\n  Flags2[Flags2[\"VKILL\"] = 3] = \"VKILL\";\n  Flags2[Flags2[\"VEOF\"] = 4] = \"VEOF\";\n  Flags2[Flags2[\"VTIME\"] = 5] = \"VTIME\";\n  Flags2[Flags2[\"VMIN\"] = 6] = \"VMIN\";\n  Flags2[Flags2[\"VSWTCH\"] = 7] = \"VSWTCH\";\n  Flags2[Flags2[\"VSTART\"] = 8] = \"VSTART\";\n  Flags2[Flags2[\"VSTOP\"] = 9] = \"VSTOP\";\n  Flags2[Flags2[\"VSUSP\"] = 10] = \"VSUSP\";\n  Flags2[Flags2[\"VEOL\"] = 11] = \"VEOL\";\n  Flags2[Flags2[\"VREPRINT\"] = 12] = \"VREPRINT\";\n  Flags2[Flags2[\"VDISCARD\"] = 13] = \"VDISCARD\";\n  Flags2[Flags2[\"VWERASE\"] = 14] = \"VWERASE\";\n  Flags2[Flags2[\"VLNEXT\"] = 15] = \"VLNEXT\";\n  Flags2[Flags2[\"VEOL2\"] = 16] = \"VEOL2\";\n  return Flags2;\n})(Flags || {});\nvar Termios = class _Termios {\n  constructor(iflag, oflag, cflag, lflag, cc) {\n    this.iflag = iflag;\n    this.oflag = oflag;\n    this.cflag = cflag;\n    this.lflag = lflag;\n    this.cc = cc;\n    this.ISTRIP_P = (this.iflag & 32 /* ISTRIP */) != 0;\n    this.INLCR_P = (this.iflag & 64 /* INLCR */) != 0;\n    this.IGNCR_P = (this.iflag & 128 /* IGNCR */) != 0;\n    this.ICRNL_P = (this.iflag & 256 /* ICRNL */) != 0;\n    this.IUCLC_P = (this.iflag & 512 /* IUCLC */) != 0;\n    this.IXON_P = (this.iflag & 1024 /* IXON */) != 0;\n    this.IXANY_P = (this.iflag & 2048 /* IXANY */) != 0;\n    this.IUTF8_P = (this.iflag & 16384 /* IUTF8 */) != 0;\n    this.OPOST_P = (this.oflag & 1 /* OPOST */) != 0;\n    this.OLCUC_P = (this.oflag & 2 /* OLCUC */) != 0;\n    this.ONLCR_P = (this.oflag & 4 /* ONLCR */) != 0;\n    this.OCRNL_P = (this.oflag & 8 /* OCRNL */) != 0;\n    this.ONOCR_P = (this.oflag & 16 /* ONOCR */) != 0;\n    this.ONLRET_P = (this.oflag & 32 /* ONLRET */) != 0;\n    this.TABDLY_XTABS_P = (this.oflag & 6144 /* TABDLY */) == 6144 /* XTABS */;\n    this.ISIG_P = (this.lflag & 1 /* ISIG */) != 0;\n    this.ICANON_P = (this.lflag & 2 /* ICANON */) != 0;\n    this.ECHO_P = (this.lflag & 8 /* ECHO */) != 0;\n    this.ECHOE_P = (this.lflag & 16 /* ECHOE */) != 0;\n    this.ECHOK_P = (this.lflag & 32 /* ECHOK */) != 0;\n    this.ECHONL_P = (this.lflag & 64 /* ECHONL */) != 0;\n    this.NOFLSH_P = (this.lflag & 128 /* NOFLSH */) != 0;\n    this.ECHOCTL_P = (this.lflag & 512 /* ECHOCTL */) != 0;\n    this.ECHOPRT_P = (this.lflag & 1024 /* ECHOPRT */) != 0;\n    this.ECHOKE_P = (this.lflag & 2048 /* ECHOKE */) != 0;\n    this.IEXTEN_P = (this.lflag & 32768 /* IEXTEN */) != 0;\n    this.INTR_V = this.cc[0 /* VINTR */];\n    this.QUIT_V = this.cc[1 /* VQUIT */];\n    this.ERASE_V = this.cc[2 /* VERASE */];\n    this.KILL_V = this.cc[3 /* VKILL */];\n    this.EOF_V = this.cc[4 /* VEOF */];\n    this.TIME_V = this.cc[5 /* VTIME */];\n    this.MIN_V = this.cc[6 /* VMIN */];\n    this.SWTCH_V = this.cc[7 /* VSWTCH */];\n    this.START_V = this.cc[8 /* VSTART */];\n    this.STOP_V = this.cc[9 /* VSTOP */];\n    this.SUSP_V = this.cc[10 /* VSUSP */];\n    this.EOL_V = this.cc[11 /* VEOL */];\n    this.REPRINT_V = this.cc[12 /* VREPRINT */];\n    this.DISCARD_V = this.cc[13 /* VDISCARD */];\n    this.WERASE_V = this.cc[14 /* VWERASE */];\n    this.LNEXT_V = this.cc[15 /* VLNEXT */];\n    this.EOL2_V = this.cc[16 /* VEOL2 */];\n  }\n  static fromConfig(config) {\n    return new _Termios(\n      config.iflag,\n      config.oflag,\n      config.cflag,\n      config.lflag,\n      config.cc\n    );\n  }\n  clone() {\n    return _Termios.fromConfig(this);\n  }\n};\nvar defaultTermios = new Termios(\n  256 /* ICRNL */ | 1024 /* IXON */ | 8192 /* IMAXBEL */ | 16384 /* IUTF8 */,\n  1 /* OPOST */ | 4 /* ONLCR */,\n  191,\n  // c_cflag is not supported\n  1 /* ISIG */ | 2 /* ICANON */ | 8 /* ECHO */ | 16 /* ECHOE */ | 32 /* ECHOK */ | 512 /* ECHOCTL */ | 2048 /* ECHOKE */ | 32768 /* IEXTEN */,\n  [\n    3,\n    28,\n    127,\n    21,\n    4,\n    0,\n    1,\n    0,\n    17,\n    19,\n    26,\n    0,\n    18,\n    15,\n    23,\n    22,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  ]\n);\n\n// src/lineDiscipline.ts\nvar LineDiscipline = class {\n  // flushed after NL is input (in ICANON mode)\n  constructor() {\n    // callbacks\n    this._onWriteToLower = new EventEmitter();\n    this.onWriteToLower = this._onWriteToLower.register;\n    this._onWriteToUpper = new EventEmitter();\n    this.onWriteToUpper = this._onWriteToUpper.register;\n    this._onSignalToUpper = new EventEmitter();\n    this.onSignalToUpper = this._onSignalToUpper.register;\n    this._onFlowActivated = new EventEmitter();\n    this.onFlowActivated = this._onFlowActivated.register;\n    this._onFlowDeactivated = new EventEmitter();\n    this.onFlowDeactivated = this._onFlowDeactivated.register;\n    // states\n    this.T = defaultTermios;\n    this.keyActions = new Array(256).fill(\"normal\");\n    this.flowActivated = true;\n    // false after VSTOP (C-s), true after VSTART (C-q)\n    this.column = 0;\n    // the column that the cursor is in\n    this.baseColumn = 0;\n    // the column that starts the to-upper buffer\n    this.vlnext = false;\n    // waiting for the next character after VLNEXT (C-v)\n    this.echoprt = false;\n    // erasing with ECHOPRT\n    this.toLowerBuf = [];\n    // flushed immediately every call\n    this.toUpperBuf = [];\n    this.termios = defaultTermios;\n  }\n  activateFlow() {\n    this.flowActivated = true;\n    this._onFlowActivated.fire();\n  }\n  deactivateFlow() {\n    this.flowActivated = false;\n    this._onFlowDeactivated.fire();\n  }\n  get flow() {\n    return this.flowActivated;\n  }\n  get termios() {\n    return this.T;\n  }\n  set termios(T) {\n    this.T = T;\n    const keyActions = new Array(256).fill(\"normal\");\n    if (T.ICANON_P) {\n      keyActions[T.EOF_V] = \"VEOF\";\n      keyActions[T.EOL_V] = \"VEOL\";\n      keyActions[T.EOL2_V] = \"VEOL\";\n      keyActions[T.ERASE_V] = \"VERASE\";\n      keyActions[T.KILL_V] = \"VKILL\";\n      if (T.IEXTEN_P) {\n        keyActions[T.REPRINT_V] = \"VREPRINT\";\n        keyActions[T.WERASE_V] = \"VWERASE\";\n      }\n    }\n    if (T.IEXTEN_P) {\n      keyActions[T.LNEXT_V] = \"VLNEXT\";\n    }\n    if (T.IXON_P) {\n      keyActions[T.START_V] = \"VSTART\";\n      keyActions[T.STOP_V] = \"VSTOP\";\n    }\n    if (T.ISIG_P) {\n      keyActions[T.INTR_V] = \"VINTR\";\n      keyActions[T.QUIT_V] = \"VQUIT\";\n      keyActions[T.SUSP_V] = \"VSUSP\";\n    }\n    keyActions[0] = \"normal\";\n    this.keyActions = keyActions;\n    if (!this.T.IXON_P) {\n      this.activateFlow();\n      this.flushToLower();\n    }\n  }\n  clearToLower() {\n    this.toLowerBuf.length = 0;\n  }\n  flushToLower() {\n    if (this.flowActivated == false) return;\n    this._onWriteToLower.fire(this.toLowerBuf);\n    this.clearToLower();\n  }\n  outputToLower(buf) {\n    this.toLowerBuf.push(...buf);\n  }\n  updateBaseColumn() {\n    if (this.toUpperBuf.length == 0) {\n      this.baseColumn = this.column;\n    }\n  }\n  clearToUpper() {\n    this.toUpperBuf.length = 0;\n    this.updateBaseColumn();\n  }\n  flushToUpper() {\n    this._onWriteToUpper.fire(this.toUpperBuf);\n    this.clearToUpper();\n  }\n  outputToUpper(c) {\n    this.toUpperBuf.push(c);\n  }\n  outputToLowerWithPostprocess(c) {\n    if (this.T.OPOST_P) {\n      switch (c) {\n        case BS:\n          if (this.column > 0) this.column--;\n          this.outputToLower([BS]);\n          break;\n        case TAB: {\n          const spaces = 8 - this.column % 8;\n          this.column += spaces;\n          this.outputToLower(\n            this.T.TABDLY_XTABS_P ? new Array(spaces).fill(SP) : [TAB]\n          );\n          break;\n        }\n        case NL:\n          if (this.T.ONLCR_P) {\n            this.baseColumn = this.column = 0;\n            this.outputToLower([CR, NL]);\n          } else if (this.T.ONLRET_P) {\n            this.column = 0;\n            this.outputToLower([NL]);\n          } else {\n            this.baseColumn = this.column;\n            this.outputToLower([NL]);\n          }\n          break;\n        case CR:\n          if (this.T.ONOCR_P && this.column == 0) {\n          } else if (this.T.OCRNL_P) {\n            if (this.T.ONLRET_P) this.baseColumn = this.column = 0;\n            this.outputToLower([NL]);\n          } else {\n            this.baseColumn = this.column = 0;\n            this.outputToLower([CR]);\n          }\n          break;\n        default:\n          if (!(this.T.IUTF8_P && isUtf8ContinuationByte(c))) this.column++;\n          this.outputToLower(this.T.OLCUC_P ? [toupper(c)] : [c]);\n          break;\n      }\n    } else {\n      this.outputToLower([c]);\n    }\n  }\n  echoToLower(chars, raw) {\n    if (typeof chars == \"number\") chars = [chars];\n    for (const c of chars) {\n      if (this.T.ECHOCTL_P && iscntrl(c) && c != TAB && !raw) {\n        this.outputToLower([94, c ^ 64]);\n        this.column += 2;\n      } else {\n        this.outputToLowerWithPostprocess(c);\n      }\n    }\n  }\n  inputFromLowerWithPreprocess(c) {\n    if (c == CR) {\n      if (this.T.IGNCR_P) return;\n      if (this.T.ICRNL_P) c = NL;\n    } else if (c == NL && this.T.INLCR_P) {\n      c = CR;\n    }\n    if (this.T.ICANON_P && c == NL) {\n      if (this.T.ECHO_P || this.T.ECHONL_P) {\n        this.echoToLower(NL, true);\n        this.flushToLower();\n      }\n      this.outputToUpper(NL);\n      this.flushToUpper();\n    } else if (this.T.ECHO_P) {\n      this.finishECHOPRT();\n      this.updateBaseColumn();\n      if (c == NL) {\n        this.echoToLower(NL, true);\n      } else {\n        this.echoToLower(c);\n      }\n      this.flushToLower();\n      this.outputToUpper(c);\n    } else {\n      this.outputToUpper(c);\n    }\n  }\n  erase(type) {\n    if (this.toUpperBuf.length == 0) return;\n    if (type == \"VKILL\") {\n      if (!this.T.ECHO_P) {\n        this.clearToUpper();\n        return;\n      }\n      if (!this.T.ECHOK_P || !this.T.ECHOKE_P || !this.T.ECHOE_P) {\n        this.clearToUpper();\n        this.finishECHOPRT();\n        this.echoToLower(this.T.KILL_V);\n        if (this.T.ECHOK_P) this.echoToLower(NL, true);\n        return;\n      }\n    }\n    let alnumsFound = false;\n    for (let idx = this.toUpperBuf.length - 1; idx >= 0; idx--) {\n      const c = this.toUpperBuf[idx];\n      if (this.T.IUTF8_P && isUtf8ContinuationByte(c)) continue;\n      if (type == \"VWERASE\") {\n        if (isalnum(c) || c == 95) {\n          alnumsFound = true;\n        } else if (alnumsFound) break;\n      }\n      const removedChar = this.toUpperBuf.splice(idx);\n      if (this.T.ECHO_P) {\n        if (this.T.ECHOPRT_P) {\n          this.startECHOPRT();\n          this.echoToLower(removedChar);\n        } else if (type == \"VERASE\" && !this.T.ECHOE_P) {\n          this.echoToLower(this.T.ERASE_V);\n        } else if (c == TAB) {\n          let count = 0;\n          let tabFound = false;\n          for (let idx2 = this.toUpperBuf.length - 1; idx2 >= 0; idx2--) {\n            const c2 = this.toUpperBuf[idx2];\n            if (c2 == TAB) {\n              tabFound = true;\n              break;\n            } else if (iscntrl(c2)) {\n              if (this.T.ECHOCTL_P) count += 2;\n            } else if (this.T.IUTF8_P && isUtf8ContinuationByte(c2)) {\n            } else {\n              count++;\n            }\n          }\n          if (!tabFound) count += this.baseColumn;\n          count = 8 - count % 8;\n          this.outputToLower(new Array(count).fill(BS));\n          this.column = Math.max(0, this.column - count);\n        } else {\n          if (iscntrl(c) && this.T.ECHOCTL_P) {\n            this.echoToLower([BS, SP, BS], true);\n          }\n          if (!iscntrl(c) || this.T.ECHOCTL_P) {\n            this.echoToLower([BS, SP, BS], true);\n          }\n        }\n      }\n      if (type == \"VERASE\") break;\n    }\n    if (this.toUpperBuf.length == 0) {\n      this.clearToUpper();\n      if (this.T.ECHO_P) this.finishECHOPRT();\n    }\n  }\n  startECHOPRT() {\n    if (!this.echoprt) {\n      this.echoToLower(92, true);\n      this.echoprt = true;\n    }\n  }\n  finishECHOPRT() {\n    if (this.echoprt) {\n      this.echoToLower(47, true);\n      this.echoprt = false;\n    }\n  }\n  signal(sig, c) {\n    this._onSignalToUpper.fire(sig);\n    if (!this.T.NOFLSH_P) {\n      this.clearToLower();\n      this.clearToUpper();\n    }\n    if (this.T.IXON_P) this.activateFlow();\n    if (this.T.ECHO_P) this.echoToLower(c);\n    this.flushToLower();\n  }\n  checkStartFlow() {\n    if (this.flowActivated == false && this.T.IXON_P && this.T.IXANY_P) {\n      this.activateFlow();\n      this.flushToLower();\n    }\n  }\n  nextLiteral() {\n    this.vlnext = true;\n    if (this.T.ECHO_P) {\n      this.finishECHOPRT();\n      if (this.T.ECHOCTL_P) {\n        this.echoToLower([94, BS], true);\n        this.flushToLower();\n      }\n    }\n  }\n  reprint() {\n    this.finishECHOPRT();\n    this.echoToLower(this.T.REPRINT_V);\n    this.echoToLower(NL, true);\n    this.echoToLower(this.toUpperBuf);\n  }\n  writeFromLower(arg) {\n    const buf = typeof arg == \"string\" ? stringToUtf8Bytes(arg) : arg;\n    for (let c of buf) {\n      if (this.T.ISTRIP_P) c &= 127;\n      if (this.T.IUCLC_P && this.T.IEXTEN_P) c = tolower(c);\n      const keyAction = this.vlnext ? \"normal\" : this.keyActions[c];\n      this.vlnext = false;\n      switch (keyAction) {\n        case \"normal\":\n          this.checkStartFlow();\n          this.inputFromLowerWithPreprocess(c);\n          break;\n        case \"VERASE\":\n        case \"VWERASE\":\n        case \"VKILL\":\n          this.checkStartFlow();\n          this.erase(keyAction);\n          this.flushToLower();\n          break;\n        case \"VEOF\":\n          this.checkStartFlow();\n          this.flushToUpper();\n          break;\n        case \"VEOL\":\n          this.checkStartFlow();\n          if (this.T.ECHO_P) {\n            this.echoToLower(c);\n            this.flushToLower();\n          }\n          this.outputToUpper(c);\n          this.flushToUpper();\n          break;\n        case \"VLNEXT\":\n          this.checkStartFlow();\n          this.nextLiteral();\n          break;\n        case \"VREPRINT\":\n          this.checkStartFlow();\n          this.reprint();\n          this.flushToLower();\n          break;\n        case \"VSTART\":\n          this.activateFlow();\n          this.flushToLower();\n          break;\n        case \"VSTOP\":\n          this.deactivateFlow();\n          break;\n        case \"VINTR\":\n          this.signal(\"SIGINT\", c);\n          break;\n        case \"VQUIT\":\n          this.signal(\"SIGQUIT\", c);\n          break;\n        case \"VSUSP\":\n          this.signal(\"SIGTSTP\", c);\n          break;\n      }\n    }\n    if (!this.T.ICANON_P) {\n      this.flushToUpper();\n    }\n  }\n  writeFromUpper(arg) {\n    if (this.flowActivated == false) {\n      throw \"Do not write anything during flowStatus is stopped\";\n    }\n    const buf = typeof arg == \"string\" ? stringToUtf8Bytes(arg) : arg;\n    for (const c of buf) this.outputToLowerWithPostprocess(c);\n    this.flushToLower();\n  }\n};\n\n// src/pty.ts\nvar bufferLimit = 4096;\nvar Master = class {\n  constructor(ldisc, slave) {\n    this.ldisc = ldisc;\n    this.slave = slave;\n    this.disposables = [];\n    this._onWrite = new EventEmitter();\n    this.onWrite = this._onWrite.register;\n    this.fromLdiscToLowerBuffer = [];\n    this.waitingForLower = false;\n    const flushToLower = () => {\n      if (this.fromLdiscToLowerBuffer.length >= 1) {\n        this.waitingForLower = true;\n        const buf = new Uint8Array(this.fromLdiscToLowerBuffer.splice(0, 4096));\n        if (this.fromLdiscToLowerBuffer.length <= bufferLimit)\n          this.notifyWritable();\n        this._onWrite.fire([buf, flushToLower]);\n      } else {\n        this.waitingForLower = false;\n      }\n    };\n    this.ldisc.onWriteToLower((buf) => {\n      this.fromLdiscToLowerBuffer.push(...buf);\n      if (!this.waitingForLower) flushToLower();\n    });\n    const { notifyWritable, notifyResize } = slave.initFromMaster();\n    this.notifyWritable = notifyWritable;\n    this.notifyResize = notifyResize;\n  }\n  activate(xterm) {\n    this.onWrite(([buf, callback]) => xterm.write(buf, callback));\n    const onData = (str) => this.ldisc.writeFromLower(str);\n    this.disposables.push(\n      xterm.onData(onData),\n      xterm.onBinary(onData),\n      xterm.onResize(({ cols, rows }) => this.notifyResize(rows, cols))\n    );\n  }\n  dispose() {\n    this.disposables.forEach((d) => d.dispose());\n    this.disposables.length = 0;\n  }\n};\nvar Slave = class {\n  constructor(ldisc) {\n    this.ldisc = ldisc;\n    this._onReadable = new EventEmitter();\n    this.onReadable = this._onReadable.register;\n    this._onWritable = new EventEmitter();\n    this.onWritable = this._onWritable.register;\n    this._onSignal = new EventEmitter();\n    this.onSignal = this._onSignal.register;\n    this.fromLdiscToUpperBuffer = [];\n    this.fromUpperToLdiscBuffer = [];\n    this.winsize = [80, 24];\n    this.ldisc.onWriteToUpper((buf) => {\n      this.fromLdiscToUpperBuffer.push(...buf);\n      this._onReadable.fire();\n    });\n    this.ldisc.onFlowActivated(() => {\n      if (this.fromUpperToLdiscBuffer.length >= 1) {\n        this.ldisc.writeFromUpper(this.fromUpperToLdiscBuffer);\n        this.fromUpperToLdiscBuffer.length = 0;\n      }\n    });\n    this.ldisc.onSignalToUpper((sig) => {\n      this._onSignal.fire(sig);\n    });\n  }\n  initFromMaster() {\n    return {\n      notifyWritable: () => this._onWritable.fire(),\n      notifyResize: (rows, cols) => {\n        this.winsize = [cols, rows];\n        this._onSignal.fire(\"SIGWINCH\");\n      }\n    };\n  }\n  get readable() {\n    return this.fromLdiscToUpperBuffer.length >= 1;\n  }\n  read(length) {\n    const len = typeof length !== \"undefined\" ? Math.min(this.fromLdiscToUpperBuffer.length, length) : this.fromLdiscToUpperBuffer.length;\n    return this.fromLdiscToUpperBuffer.splice(0, len);\n  }\n  get writable() {\n    return this.fromUpperToLdiscBuffer.length <= bufferLimit;\n  }\n  write(arg) {\n    const buf = typeof arg == \"string\" ? stringToUtf8Bytes(arg) : arg;\n    this.fromUpperToLdiscBuffer = this.fromUpperToLdiscBuffer.concat(buf);\n    if (this.ldisc.flow) {\n      this.ldisc.writeFromUpper(this.fromUpperToLdiscBuffer);\n      this.fromUpperToLdiscBuffer.length = 0;\n    }\n  }\n  ioctl(req, arg) {\n    switch (req) {\n      case \"TCGETS\":\n        return this.ldisc.termios.clone();\n      case \"TCSETS\":\n        this.ldisc.termios = Termios.fromConfig(arg);\n        return;\n      case \"TIOCGWINSZ\":\n        return this.winsize.slice();\n    }\n  }\n};\nvar openpty = () => {\n  const ldisc = new LineDiscipline();\n  const slave = new Slave(ldisc);\n  const master = new Master(ldisc, slave);\n  return { master, slave };\n};\n\n// src/client-server/termiosData.ts\nvar termiosToData = (termios) => {\n  const data = [termios.iflag, termios.oflag, termios.cflag, termios.lflag];\n  let word = 0;\n  let offset = 8;\n  for (let i = 0; i < termios.cc.length; i++) {\n    word |= termios.cc[i] << offset;\n    offset += 8;\n    if (offset == 32) {\n      data.push(word);\n      word = 0;\n      offset = 0;\n    }\n  }\n  data.push(word);\n  return data;\n};\nvar dataToTermios = (data) => {\n  const cc = [];\n  let ptr = 4;\n  let word = data[ptr++];\n  let offset = 8;\n  for (let i = 0; i < 32; i++) {\n    cc.push(word >> offset & 255);\n    offset += 8;\n    if (offset >= 32) {\n      word = data[ptr++];\n      offset = 0;\n    }\n  }\n  return new Termios(data[0], data[1], data[2], data[3], cc);\n};\n\n// src/client-server/ttyClient.ts\nvar TtyClient = class {\n  constructor(shared) {\n    this.streamCtrl = new Int32Array(shared, 0, 1);\n    this.streamData = new Int32Array(shared, 4);\n  }\n  req(r) {\n    this.streamCtrl[0] = 0;\n    self.postMessage(r);\n    Atomics.wait(this.streamCtrl, 0, 0);\n  }\n  onRead(length) {\n    if (!length) length = this.streamData.length - 1;\n    this.req({ ttyRequestType: \"read\", length });\n    const len = this.streamData[0];\n    return Array.from(this.streamData.slice(1, len + 1));\n  }\n  onWrite(buf) {\n    this.req({ ttyRequestType: \"write\", buf });\n  }\n  onWaitForReadable(timeout) {\n    this.req({ ttyRequestType: \"poll\", timeout });\n    return this.streamData[0] == 1;\n  }\n  onIoctlTcgets() {\n    this.req({ ttyRequestType: \"tcgets\" });\n    return dataToTermios(Array.from(this.streamData.slice(0, 13)));\n  }\n  onIoctlTcsets(termios) {\n    const data = termiosToData(termios);\n    this.req({ ttyRequestType: \"tcsets\", data });\n  }\n  onIoctlTiocgwinsz() {\n    this.req({ ttyRequestType: \"tiocgwinsz\" });\n    return [this.streamData[0], this.streamData[1]];\n  }\n};\n\n// src/client-server/ttyServer.ts\nvar TtyServer = class {\n  constructor(slave) {\n    this.slave = slave;\n    this.shared = new SharedArrayBuffer(4 + 256);\n    this.streamCtrl = new Int32Array(this.shared, 0, 1);\n    this.streamData = new Int32Array(this.shared, 4);\n    this.state = \"idle\";\n    this.timeoutHandler = null;\n    this.fromWorkerBuf = [];\n    this.toWorkerBuf = [];\n    this.stop_ = null;\n    slave.onWritable(() => {\n      if (this.fromWorkerBuf.length >= 1) this.feedFromWorker();\n    });\n    slave.onReadable(() => {\n      this.toWorkerBuf.push(...slave.read());\n      switch (this.state) {\n        case \"poll\":\n          this.waitForReadable(0);\n          break;\n        case \"input\":\n          this.feedToWorker(this.toWorkerBuf.length);\n          break;\n      }\n    });\n    slave.onSignal((sig) => {\n      console.info(`A signal ${sig} is currently ignored`);\n    });\n  }\n  ack() {\n    Atomics.store(this.streamCtrl, 0, 1);\n    Atomics.notify(this.streamCtrl, 0);\n    this.state = \"idle\";\n  }\n  feedToWorker(length) {\n    if (this.state != \"input\") throw \"worker does not wait for input\";\n    if (length > this.streamData.length - 1)\n      length = this.streamData.length - 1;\n    const buf = this.toWorkerBuf.splice(0, length);\n    this.streamData[0] = buf.length;\n    this.streamData.set(buf, 1);\n    this.ack();\n  }\n  feedFromWorker() {\n    if (this.fromWorkerBuf.length == 0) throw \"worker does not wait for output\";\n    if (this.slave.writable) {\n      this.ack();\n      this.slave.write(this.fromWorkerBuf.splice(0));\n    }\n  }\n  waitForReadable(timeout) {\n    if (this.state != \"poll\") throw \"worker does not wait for poll\";\n    if (this.timeoutHandler) {\n      clearTimeout(this.timeoutHandler);\n      this.timeoutHandler = null;\n    }\n    if (this.toWorkerBuf.length > 0) {\n      this.streamData[0] = 1;\n      this.ack();\n    } else {\n      if (timeout < 0) {\n      } else if (timeout > 0) {\n        this.timeoutHandler = setTimeout(\n          () => this.waitForReadable(0),\n          timeout * 1e3\n        );\n      } else {\n        this.streamData[0] = 2;\n        this.ack();\n      }\n    }\n  }\n  start(worker, callback) {\n    this.stop();\n    let stop = false;\n    this.stop_ = () => stop = true;\n    worker.onmessage = (ev) => {\n      const req_ = ev.data;\n      if (typeof req_ == \"object\" && req_.ttyRequestType) {\n        if (stop) return;\n        const req = req_;\n        switch (req.ttyRequestType) {\n          case \"read\":\n            this.state = \"input\";\n            if (this.toWorkerBuf.length >= 1) this.feedToWorker(req.length);\n            break;\n          case \"write\":\n            this.fromWorkerBuf.push(...req.buf);\n            this.feedFromWorker();\n            break;\n          case \"poll\":\n            this.state = \"poll\";\n            this.waitForReadable(req.timeout);\n            break;\n          case \"tcgets\":\n            this.streamData.set(termiosToData(this.slave.ioctl(\"TCGETS\")));\n            this.ack();\n            break;\n          case \"tcsets\":\n            this.slave.ioctl(\"TCSETS\", dataToTermios(req.data));\n            this.ack();\n            break;\n          case \"tiocgwinsz\": {\n            const [rows, cols] = this.slave.ioctl(\"TIOCGWINSZ\");\n            this.streamData[0] = rows;\n            this.streamData[1] = cols;\n            this.ack();\n            break;\n          }\n        }\n      } else if (callback) {\n        callback(ev);\n      }\n    };\n    worker.postMessage(this.shared);\n  }\n  stop() {\n    if (this.stop_) this.stop_();\n  }\n};\n\n\n\n\n\n\nexports.Flags = Flags; exports.Termios = Termios; exports.TtyClient = TtyClient; exports.TtyServer = TtyServer; exports.openpty = openpty;\n//# sourceMappingURL=index.js.map","type Listener<T> = (arg: T) => void;\nexport type Event<T> = (listener: Listener<T>) => { dispose: () => void };\n\nexport class EventEmitter<T> {\n  private listeners = new Set<Listener<T>>();\n\n  private _register(listener: Listener<T>) {\n    this.listeners.add(listener);\n    return {\n      dispose: () => {\n        this.listeners.delete(listener);\n      }\n    };\n  }\n\n  register = this._register.bind(this);\n\n  public fire(arg: T): void {\n    for (const listener of this.listeners) {\n      try {\n        listener(arg);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }\n}\n","export const BS = 8;\nexport const TAB = 9;\nexport const NL = 10;\nexport const CR = 13;\nexport const SP = 32;\n\nexport const isalnum = (c: number) =>\n  (0x30 <= c && c <= 0x39) ||\n  (0x41 <= c && c <= 0x5a) ||\n  c == 0x5f ||\n  (0x61 <= c && c <= 0x7a);\nexport const iscntrl = (c: number) =>\n  (0x00 <= c && c <= 0x1f && c != 0x09) || c == 0x7f;\nexport const isUtf8ContinuationByte = (c: number) => (c & 0xc0) == 0x80;\nexport const tolower = (c: number) => (0x41 <= c && c <= 0x5a ? c + 0x20 : c);\nexport const toupper = (c: number) => (0x61 <= c && c <= 0x7a ? c - 0x20 : c);\n\nconst utf8Encoder = new TextEncoder();\n\nexport const stringToUtf8Bytes = (str: string) =>\n  Array.from(utf8Encoder.encode(str));\n","// This module provides a Termios class for termios struct data.\n//\n// https://man7.org/linux/man-pages/man3/termios.3.html\n\nexport const enum Flags {\n  // c_iflag\n  ISTRIP = 0x0020,\n  INLCR = 0x0040,\n  IGNCR = 0x0080,\n  ICRNL = 0x0100,\n  IUCLC = 0x0200,\n  IXON = 0x0400,\n  IXANY = 0x0800,\n  IMAXBEL = 0x2000,\n  IUTF8 = 0x4000,\n\n  // c_oflag\n  OPOST = 0x0001,\n  OLCUC = 0x0002,\n  ONLCR = 0x0004,\n  OCRNL = 0x0008,\n  ONOCR = 0x0010,\n  ONLRET = 0x0020,\n  TABDLY = 0x1800,\n  XTABS = 0x1800,\n\n  // c_lflag\n  ISIG = 0x0001,\n  ICANON = 0x0002,\n  ECHO = 0x0008,\n  ECHOE = 0x0010,\n  ECHOK = 0x0020,\n  ECHONL = 0x0040,\n  NOFLSH = 0x0080,\n  ECHOCTL = 0x0200,\n  ECHOPRT = 0x0400,\n  ECHOKE = 0x0800,\n  IEXTEN = 0x8000,\n\n  // c_cc\n  VINTR = 0,\n  VQUIT = 1,\n  VERASE = 2,\n  VKILL = 3,\n  VEOF = 4,\n  VTIME = 5,\n  VMIN = 6,\n  VSWTCH = 7,\n  VSTART = 8,\n  VSTOP = 9,\n  VSUSP = 10,\n  VEOL = 11,\n  VREPRINT = 12,\n  VDISCARD = 13,\n  VWERASE = 14,\n  VLNEXT = 15,\n  VEOL2 = 16\n}\n\nexport interface TermiosConfig {\n  readonly iflag: number;\n  readonly oflag: number;\n  readonly cflag: number;\n  readonly lflag: number;\n  readonly cc: ReadonlyArray<number>;\n}\n\nexport class Termios implements TermiosConfig {\n  readonly ISTRIP_P: boolean;\n  readonly INLCR_P: boolean;\n  readonly IGNCR_P: boolean;\n  readonly ICRNL_P: boolean;\n  readonly IUCLC_P: boolean;\n  readonly IXON_P: boolean;\n  readonly IXANY_P: boolean;\n  readonly IUTF8_P: boolean;\n  readonly OPOST_P: boolean;\n  readonly OLCUC_P: boolean;\n  readonly ONLCR_P: boolean;\n  readonly OCRNL_P: boolean;\n  readonly ONOCR_P: boolean;\n  readonly ONLRET_P: boolean;\n  readonly TABDLY_XTABS_P: boolean;\n  readonly ISIG_P: boolean;\n  readonly ICANON_P: boolean;\n  readonly ECHO_P: boolean;\n  readonly ECHOE_P: boolean;\n  readonly ECHOK_P: boolean;\n  readonly ECHONL_P: boolean;\n  readonly NOFLSH_P: boolean;\n  readonly ECHOCTL_P: boolean;\n  readonly ECHOPRT_P: boolean;\n  readonly ECHOKE_P: boolean;\n  readonly IEXTEN_P: boolean;\n\n  readonly INTR_V: number;\n  readonly QUIT_V: number;\n  readonly ERASE_V: number;\n  readonly KILL_V: number;\n  readonly EOF_V: number;\n  readonly TIME_V: number;\n  readonly MIN_V: number;\n  readonly SWTCH_V: number;\n  readonly START_V: number;\n  readonly STOP_V: number;\n  readonly SUSP_V: number;\n  readonly EOL_V: number;\n  readonly REPRINT_V: number;\n  readonly DISCARD_V: number;\n  readonly WERASE_V: number;\n  readonly LNEXT_V: number;\n  readonly EOL2_V: number;\n\n  constructor(\n    readonly iflag: number,\n    readonly oflag: number,\n    readonly cflag: number,\n    readonly lflag: number,\n    readonly cc: ReadonlyArray<number>\n  ) {\n    this.ISTRIP_P = (this.iflag & Flags.ISTRIP) != 0;\n    this.INLCR_P = (this.iflag & Flags.INLCR) != 0;\n    this.IGNCR_P = (this.iflag & Flags.IGNCR) != 0;\n    this.ICRNL_P = (this.iflag & Flags.ICRNL) != 0;\n    this.IUCLC_P = (this.iflag & Flags.IUCLC) != 0;\n    this.IXON_P = (this.iflag & Flags.IXON) != 0;\n    this.IXANY_P = (this.iflag & Flags.IXANY) != 0;\n    this.IUTF8_P = (this.iflag & Flags.IUTF8) != 0;\n    this.OPOST_P = (this.oflag & Flags.OPOST) != 0;\n    this.OLCUC_P = (this.oflag & Flags.OLCUC) != 0;\n    this.ONLCR_P = (this.oflag & Flags.ONLCR) != 0;\n    this.OCRNL_P = (this.oflag & Flags.OCRNL) != 0;\n    this.ONOCR_P = (this.oflag & Flags.ONOCR) != 0;\n    this.ONLRET_P = (this.oflag & Flags.ONLRET) != 0;\n    this.TABDLY_XTABS_P = (this.oflag & Flags.TABDLY) == Flags.XTABS;\n    this.ISIG_P = (this.lflag & Flags.ISIG) != 0;\n    this.ICANON_P = (this.lflag & Flags.ICANON) != 0;\n    this.ECHO_P = (this.lflag & Flags.ECHO) != 0;\n    this.ECHOE_P = (this.lflag & Flags.ECHOE) != 0;\n    this.ECHOK_P = (this.lflag & Flags.ECHOK) != 0;\n    this.ECHONL_P = (this.lflag & Flags.ECHONL) != 0;\n    this.NOFLSH_P = (this.lflag & Flags.NOFLSH) != 0;\n    this.ECHOCTL_P = (this.lflag & Flags.ECHOCTL) != 0;\n    this.ECHOPRT_P = (this.lflag & Flags.ECHOPRT) != 0;\n    this.ECHOKE_P = (this.lflag & Flags.ECHOKE) != 0;\n    this.IEXTEN_P = (this.lflag & Flags.IEXTEN) != 0;\n\n    this.INTR_V = this.cc[Flags.VINTR];\n    this.QUIT_V = this.cc[Flags.VQUIT];\n    this.ERASE_V = this.cc[Flags.VERASE];\n    this.KILL_V = this.cc[Flags.VKILL];\n    this.EOF_V = this.cc[Flags.VEOF];\n    this.TIME_V = this.cc[Flags.VTIME];\n    this.MIN_V = this.cc[Flags.VMIN];\n    this.SWTCH_V = this.cc[Flags.VSWTCH];\n    this.START_V = this.cc[Flags.VSTART];\n    this.STOP_V = this.cc[Flags.VSTOP];\n    this.SUSP_V = this.cc[Flags.VSUSP];\n    this.EOL_V = this.cc[Flags.VEOL];\n    this.REPRINT_V = this.cc[Flags.VREPRINT];\n    this.DISCARD_V = this.cc[Flags.VDISCARD];\n    this.WERASE_V = this.cc[Flags.VWERASE];\n    this.LNEXT_V = this.cc[Flags.VLNEXT];\n    this.EOL2_V = this.cc[Flags.VEOL2];\n  }\n\n  static fromConfig(config: TermiosConfig) {\n    return new Termios(\n      config.iflag,\n      config.oflag,\n      config.cflag,\n      config.lflag,\n      config.cc\n    );\n  }\n\n  clone() {\n    return Termios.fromConfig(this);\n  }\n}\n\nexport const defaultTermios = new Termios(\n  Flags.ICRNL | Flags.IXON | Flags.IMAXBEL | Flags.IUTF8,\n  Flags.OPOST | Flags.ONLCR,\n  0x00bf, // c_cflag is not supported\n  Flags.ISIG |\n    Flags.ICANON |\n    Flags.ECHO |\n    Flags.ECHOE |\n    Flags.ECHOK |\n    Flags.ECHOCTL |\n    Flags.ECHOKE |\n    Flags.IEXTEN,\n  [\n    0x03, 0x1c, 0x7f, 0x15, 0x04, 0x00, 0x01, 0x00, 0x11, 0x13, 0x1a, 0x00,\n    0x12, 0x0f, 0x17, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n  ]\n);\n","// This module provides LineDiscipline class.\n//\n// It glues the low-level device (e.g., xterm.js) with the high-level process\n// (e.g., JavaScript code and an Emscripten'ed process).\n//\n// It receives an input event from the lower layer (writeFromLower()).\n// Depending on the \"termios\" configuration, it handles some special characters\n// such as Ctrl+C, applies some translations to the input, echos it back to the\n// lower layers, etc. Finally it conveys the input to the upper layer\n// (onWriteToUpper() or onSignalToUpper()).\n//\n// It also receives an output event form the upper layer (writeFromUpper()).\n// Again, it applies some translation (such as replacing NL with CR+NL)\n// depending on termios. And finally it conveys the output to the lower layer\n// (onWriteToLower()).\n//\n//                +-------+\n//                | Upper | (e.g., an Emscripten'ed process)\n//                +-------+\n//                  |   ^\n// writeFromUpper() |   | onWriteToUpper() (and onSignalToUpper())\n//                  V   |\n//           +-----------------+\n//           | Line discipline |\n//           +-----------------+\n//                  |   ^\n// onWriteToLower() |   | writeFromLower()\n//                  V   |\n//                +-------+\n//                | Lower | (e.g., xterm.js)\n//                +-------+\n//\n// References:\n//\n// https://en.wikipedia.org/wiki/Line_discipline\n// https://man7.org/linux/man-pages/man3/termios.3.html\n// https://pubs.opengroup.org/onlinepubs/009695299/basedefs/xbd_chap11.html\n// https://pubs.opengroup.org/onlinepubs/009695299/utilities/stty.html\n// https://github.com/torvalds/linux/blob/master/drivers/tty/n_tty.c\n\nimport {\n  BS,\n  TAB,\n  NL,\n  CR,\n  SP,\n  isalnum,\n  iscntrl,\n  isUtf8ContinuationByte,\n  tolower,\n  toupper,\n  stringToUtf8Bytes,\n} from \"./utils\";\nimport { Signal } from \"./pty\";\nimport { Termios, defaultTermios } from \"./termios\";\nimport { EventEmitter, Event } from \"./eventEmitter\";\n\ntype KeyAction =\n  | \"normal\"\n  | \"VEOF\"\n  | \"VEOL\"\n  | \"VERASE\"\n  | \"VKILL\"\n  | \"VREPRINT\"\n  | \"VWERASE\"\n  | \"VLNEXT\"\n  | \"VSTART\"\n  | \"VSTOP\"\n  | \"VINTR\"\n  | \"VQUIT\"\n  | \"VSUSP\";\n\nexport class LineDiscipline {\n  // callbacks\n  private _onWriteToLower = new EventEmitter<number[]>();\n  readonly onWriteToLower = this._onWriteToLower.register;\n\n  private _onWriteToUpper = new EventEmitter<number[]>();\n  readonly onWriteToUpper = this._onWriteToUpper.register;\n\n  private _onSignalToUpper = new EventEmitter<Signal>();\n  readonly onSignalToUpper = this._onSignalToUpper.register;\n\n  private _onFlowActivated = new EventEmitter<void>();\n  readonly onFlowActivated = this._onFlowActivated.register;\n\n  private _onFlowDeactivated = new EventEmitter<void>();\n  readonly onFlowDeactivated = this._onFlowDeactivated.register;\n\n  // states\n  private T = defaultTermios;\n  private keyActions: KeyAction[] = new Array(256).fill(\"normal\");\n\n  private flowActivated = true; // false after VSTOP (C-s), true after VSTART (C-q)\n  private column = 0; // the column that the cursor is in\n  private baseColumn = 0; // the column that starts the to-upper buffer\n  private vlnext = false; // waiting for the next character after VLNEXT (C-v)\n  private echoprt = false; // erasing with ECHOPRT\n\n  private toLowerBuf: number[] = []; // flushed immediately every call\n  private toUpperBuf: number[] = []; // flushed after NL is input (in ICANON mode)\n\n  constructor() {\n    this.termios = defaultTermios;\n  }\n\n  private activateFlow() {\n    this.flowActivated = true;\n    this._onFlowActivated.fire();\n  }\n\n  private deactivateFlow() {\n    this.flowActivated = false;\n    this._onFlowDeactivated.fire();\n  }\n\n  get flow() {\n    return this.flowActivated;\n  }\n\n  get termios() {\n    return this.T;\n  }\n\n  set termios(T: Termios) {\n    this.T = T;\n\n    const keyActions: KeyAction[] = new Array(256).fill(\"normal\");\n\n    if (T.ICANON_P) {\n      keyActions[T.EOF_V] = \"VEOF\";\n      keyActions[T.EOL_V] = \"VEOL\";\n      keyActions[T.EOL2_V] = \"VEOL\";\n      keyActions[T.ERASE_V] = \"VERASE\";\n      keyActions[T.KILL_V] = \"VKILL\";\n      if (T.IEXTEN_P) {\n        keyActions[T.REPRINT_V] = \"VREPRINT\";\n        keyActions[T.WERASE_V] = \"VWERASE\";\n      }\n    }\n    if (T.IEXTEN_P) {\n      keyActions[T.LNEXT_V] = \"VLNEXT\";\n    }\n    if (T.IXON_P) {\n      keyActions[T.START_V] = \"VSTART\";\n      keyActions[T.STOP_V] = \"VSTOP\";\n    }\n    if (T.ISIG_P) {\n      keyActions[T.INTR_V] = \"VINTR\";\n      keyActions[T.QUIT_V] = \"VQUIT\";\n      keyActions[T.SUSP_V] = \"VSUSP\";\n    }\n    keyActions[0] = \"normal\"; // Ignore any action for NUL character\n\n    this.keyActions = keyActions;\n\n    if (!this.T.IXON_P) {\n      this.activateFlow();\n      this.flushToLower();\n    }\n  }\n\n  private clearToLower() {\n    this.toLowerBuf.length = 0;\n  }\n\n  private flushToLower() {\n    if (this.flowActivated == false) return;\n    this._onWriteToLower.fire(this.toLowerBuf);\n    this.clearToLower();\n  }\n\n  private outputToLower(buf: number[]) {\n    this.toLowerBuf.push(...buf);\n  }\n\n  private updateBaseColumn() {\n    if (this.toUpperBuf.length == 0) {\n      this.baseColumn = this.column;\n    }\n  }\n\n  private clearToUpper() {\n    this.toUpperBuf.length = 0;\n    this.updateBaseColumn();\n  }\n\n  private flushToUpper() {\n    this._onWriteToUpper.fire(this.toUpperBuf);\n    this.clearToUpper();\n  }\n\n  private outputToUpper(c: number) {\n    this.toUpperBuf.push(c);\n  }\n\n  private outputToLowerWithPostprocess(c: number) {\n    if (this.T.OPOST_P) {\n      switch (c) {\n        case BS:\n          if (this.column > 0) this.column--;\n          this.outputToLower([BS]);\n          break;\n        case TAB: {\n          const spaces = 8 - (this.column % 8);\n          this.column += spaces;\n          this.outputToLower(\n            this.T.TABDLY_XTABS_P ? new Array(spaces).fill(SP) : [TAB]\n          );\n          break;\n        }\n        case NL:\n          if (this.T.ONLCR_P) {\n            this.baseColumn = this.column = 0;\n            this.outputToLower([CR, NL]);\n          } else if (this.T.ONLRET_P) {\n            this.column = 0;\n            this.outputToLower([NL]);\n          } else {\n            this.baseColumn = this.column;\n            this.outputToLower([NL]);\n          }\n          break;\n        case CR:\n          if (this.T.ONOCR_P && this.column == 0) {\n            // nothing printed\n          } else if (this.T.OCRNL_P) {\n            if (this.T.ONLRET_P) this.baseColumn = this.column = 0;\n            this.outputToLower([NL]);\n          } else {\n            this.baseColumn = this.column = 0;\n            this.outputToLower([CR]);\n          }\n          break;\n        default:\n          if (!(this.T.IUTF8_P && isUtf8ContinuationByte(c))) this.column++;\n          this.outputToLower(this.T.OLCUC_P ? [toupper(c)] : [c]);\n          break;\n      }\n    } else {\n      this.outputToLower([c]);\n    }\n  }\n\n  private echoToLower(chars: number | number[], raw?: boolean) {\n    if (typeof chars == \"number\") chars = [chars];\n\n    for (const c of chars) {\n      if (this.T.ECHOCTL_P && iscntrl(c) && c != TAB && !raw) {\n        this.outputToLower([94 /* '^' */, c ^ 0x40]);\n        this.column += 2;\n      } else {\n        this.outputToLowerWithPostprocess(c);\n      }\n    }\n  }\n\n  private inputFromLowerWithPreprocess(c: number) {\n    if (c == CR) {\n      if (this.T.IGNCR_P) return;\n      if (this.T.ICRNL_P) c = NL;\n    } else if (c == NL && this.T.INLCR_P) {\n      c = CR;\n    }\n\n    if (this.T.ICANON_P && c == NL) {\n      // flush the to-upper buffer\n      if (this.T.ECHO_P || this.T.ECHONL_P) {\n        this.echoToLower(NL, true);\n        this.flushToLower();\n      }\n      this.outputToUpper(NL);\n      this.flushToUpper();\n    } else if (this.T.ECHO_P) {\n      this.finishECHOPRT();\n      this.updateBaseColumn();\n      if (c == NL) {\n        this.echoToLower(NL, true);\n      } else {\n        this.echoToLower(c);\n      }\n      this.flushToLower();\n      this.outputToUpper(c);\n    } else {\n      this.outputToUpper(c);\n    }\n    // writeFromLower will flush the to-upper buffer later\n  }\n\n  private erase(type: \"VERASE\" | \"VWERASE\" | \"VKILL\") {\n    if (this.toUpperBuf.length == 0) return;\n\n    if (type == \"VKILL\") {\n      if (!this.T.ECHO_P) {\n        this.clearToUpper();\n        return;\n      }\n      if (!this.T.ECHOK_P || !this.T.ECHOKE_P || !this.T.ECHOE_P) {\n        this.clearToUpper();\n        this.finishECHOPRT();\n        this.echoToLower(this.T.KILL_V);\n        if (this.T.ECHOK_P) this.echoToLower(NL, true);\n        return;\n      }\n    }\n\n    let alnumsFound = false;\n    for (let idx = this.toUpperBuf.length - 1; idx >= 0; idx--) {\n      const c = this.toUpperBuf[idx];\n      if (this.T.IUTF8_P && isUtf8ContinuationByte(c)) continue;\n\n      if (type == \"VWERASE\") {\n        if (isalnum(c) || c == 0x5f /* '_' */) {\n          alnumsFound = true;\n        } else if (alnumsFound) break;\n      }\n\n      const removedChar = this.toUpperBuf.splice(idx);\n      if (this.T.ECHO_P) {\n        if (this.T.ECHOPRT_P) {\n          this.startECHOPRT();\n          this.echoToLower(removedChar);\n        } else if (type == \"VERASE\" && !this.T.ECHOE_P) {\n          this.echoToLower(this.T.ERASE_V);\n        } else if (c == TAB) {\n          let count = 0;\n          let tabFound = false;\n\n          for (let idx = this.toUpperBuf.length - 1; idx >= 0; idx--) {\n            const c = this.toUpperBuf[idx];\n            if (c == TAB) {\n              tabFound = true;\n              break;\n            } else if (iscntrl(c)) {\n              if (this.T.ECHOCTL_P) count += 2;\n            } else if (this.T.IUTF8_P && isUtf8ContinuationByte(c)) {\n              // ignore\n            } else {\n              count++;\n            }\n          }\n          if (!tabFound) count += this.baseColumn;\n\n          count = 8 - (count % 8);\n          this.outputToLower(new Array(count).fill(BS));\n          this.column = Math.max(0, this.column - count);\n        } else {\n          if (iscntrl(c) && this.T.ECHOCTL_P) {\n            this.echoToLower([BS, SP, BS], true);\n          }\n          if (!iscntrl(c) || this.T.ECHOCTL_P) {\n            // delete '^' of ECHOCTL\n            this.echoToLower([BS, SP, BS], true);\n          }\n        }\n      }\n      if (type == \"VERASE\") break;\n    }\n    if (this.toUpperBuf.length == 0) {\n      this.clearToUpper();\n      if (this.T.ECHO_P) this.finishECHOPRT();\n    }\n  }\n\n  private startECHOPRT() {\n    if (!this.echoprt) {\n      this.echoToLower(92 /* '\\' */, true);\n      this.echoprt = true;\n    }\n  }\n\n  private finishECHOPRT() {\n    if (this.echoprt) {\n      this.echoToLower(47 /* '/' */, true);\n      this.echoprt = false;\n    }\n  }\n\n  private signal(sig: Signal, c: number) {\n    this._onSignalToUpper.fire(sig);\n    if (!this.T.NOFLSH_P) {\n      this.clearToLower();\n      this.clearToUpper();\n    }\n    if (this.T.IXON_P) this.activateFlow();\n    if (this.T.ECHO_P) this.echoToLower(c);\n    this.flushToLower();\n  }\n\n  private checkStartFlow() {\n    if (this.flowActivated == false && this.T.IXON_P && this.T.IXANY_P) {\n      this.activateFlow();\n      this.flushToLower();\n    }\n  }\n\n  private nextLiteral() {\n    this.vlnext = true;\n    if (this.T.ECHO_P) {\n      this.finishECHOPRT();\n      if (this.T.ECHOCTL_P) {\n        this.echoToLower([94 /* '^' */, BS], true);\n        this.flushToLower();\n      }\n    }\n  }\n\n  private reprint() {\n    this.finishECHOPRT();\n    this.echoToLower(this.T.REPRINT_V);\n    this.echoToLower(NL, true);\n    this.echoToLower(this.toUpperBuf);\n  }\n\n  writeFromLower(arg: number[] | string) {\n    const buf = typeof arg == \"string\" ? stringToUtf8Bytes(arg) : arg;\n\n    for (let c of buf) {\n      if (this.T.ISTRIP_P) c &= 0x7f;\n      if (this.T.IUCLC_P && this.T.IEXTEN_P) c = tolower(c);\n\n      const keyAction = this.vlnext ? \"normal\" : this.keyActions[c];\n      this.vlnext = false;\n\n      switch (keyAction) {\n        case \"normal\":\n          this.checkStartFlow();\n          this.inputFromLowerWithPreprocess(c);\n          break;\n        case \"VERASE\":\n        case \"VWERASE\":\n        case \"VKILL\":\n          this.checkStartFlow();\n          this.erase(keyAction);\n          this.flushToLower();\n          break;\n        case \"VEOF\":\n          this.checkStartFlow();\n          this.flushToUpper();\n          break;\n        case \"VEOL\":\n          this.checkStartFlow();\n          if (this.T.ECHO_P) {\n            this.echoToLower(c);\n            this.flushToLower();\n          }\n          this.outputToUpper(c);\n          this.flushToUpper();\n          break;\n        case \"VLNEXT\":\n          this.checkStartFlow();\n          this.nextLiteral();\n          break;\n        case \"VREPRINT\":\n          this.checkStartFlow();\n          this.reprint();\n          this.flushToLower();\n          break;\n        case \"VSTART\":\n          this.activateFlow();\n          this.flushToLower();\n          break;\n        case \"VSTOP\":\n          this.deactivateFlow();\n          break;\n        case \"VINTR\":\n          this.signal(\"SIGINT\", c);\n          break;\n        case \"VQUIT\":\n          this.signal(\"SIGQUIT\", c);\n          break;\n        case \"VSUSP\":\n          this.signal(\"SIGTSTP\", c);\n          break;\n      }\n    }\n\n    if (!this.T.ICANON_P) {\n      this.flushToUpper();\n    }\n  }\n\n  writeFromUpper(arg: number[] | string) {\n    if (this.flowActivated == false) {\n      throw \"Do not write anything during flowStatus is stopped\";\n    }\n\n    const buf = typeof arg == \"string\" ? stringToUtf8Bytes(arg) : arg;\n\n    for (const c of buf) this.outputToLowerWithPostprocess(c);\n    this.flushToLower();\n  }\n}\n\nexport interface LineDiscipline {\n  readonly onWriteToLower: Event<number[]>;\n  readonly onWriteToUpper: Event<number[]>;\n  readonly onSignalToUpper: Event<Signal>;\n  readonly onFlowActivated: Event<void>;\n  readonly onFlowDeactivated: Event<void>;\n  flow: boolean;\n  termios: Termios;\n  writeFromLower: (arg: number[] | string) => void;\n  writeFromUpper: (arg: number[] | string) => void;\n}\n","// This module provides the \"openpty\" function.\n// It returns a master object, which is an addon for xterm.js, and a slave\n// object, which serves as stdin/stdout for a process.\n//\n// Typical usage:\n//\n//   // Start an xterm.js instance\n//   const xterm = new Terminal();\n//\n//   // Create master/slave objects\n//   const { master, slave } = openpty();\n//\n//   // Connect the master object to xterm.js\n//   xterm.loadAddon(ldiscAddon);\n//\n//   // Use slave.write instead of xterm.write\n//   slave.write(\"Hello, world!\\nInput your name:\");\n//\n//   // Use slave.onReadable and slave.read instead of xterm.onData\n//   slave.onReadable(() => {\n//     xterm.write(`Hi, ${ slave.read().trim() }!\\n`);\n//   });\n\nimport { Terminal, ITerminalAddon, IDisposable } from \"xterm\";\nimport { EventEmitter } from \"./eventEmitter\";\nimport { LineDiscipline } from \"./lineDiscipline\";\nimport { Termios, TermiosConfig } from \"./termios\";\nimport { stringToUtf8Bytes } from \"./utils\";\n\nexport type Signal = \"SIGINT\" | \"SIGQUIT\" | \"SIGTSTP\" | \"SIGWINCH\";\n\nconst bufferLimit = 4096;\n\nclass Master implements ITerminalAddon {\n  private disposables: IDisposable[] = [];\n\n  private _onWrite = new EventEmitter<[Uint8Array, () => void]>();\n  readonly onWrite = this._onWrite.register;\n\n  private fromLdiscToLowerBuffer: number[] = [];\n  private waitingForLower = false; // xterm.js implements buffering\n\n  private notifyWritable;\n  private notifyResize;\n\n  constructor(private ldisc: LineDiscipline, private slave: Slave) {\n    const flushToLower = () => {\n      if (this.fromLdiscToLowerBuffer.length >= 1) {\n        this.waitingForLower = true;\n\n        const buf = new Uint8Array(this.fromLdiscToLowerBuffer.splice(0, 4096));\n\n        if (this.fromLdiscToLowerBuffer.length <= bufferLimit)\n          this.notifyWritable();\n\n        this._onWrite.fire([buf, flushToLower]);\n      } else {\n        this.waitingForLower = false;\n      }\n    };\n\n    this.ldisc.onWriteToLower((buf) => {\n      this.fromLdiscToLowerBuffer.push(...buf);\n      if (!this.waitingForLower) flushToLower();\n    });\n\n    const { notifyWritable, notifyResize } = slave.initFromMaster();\n    this.notifyWritable = notifyWritable;\n    this.notifyResize = notifyResize;\n  }\n\n  activate(xterm: Terminal) {\n    this.onWrite(([buf, callback]) => xterm.write(buf, callback));\n\n    const onData = (str: string) => this.ldisc.writeFromLower(str);\n\n    this.disposables.push(\n      xterm.onData(onData),\n      xterm.onBinary(onData),\n      xterm.onResize(({ cols, rows }) => this.notifyResize(rows, cols))\n    );\n  }\n\n  dispose(): void {\n    this.disposables.forEach((d) => d.dispose());\n    this.disposables.length = 0;\n  }\n}\n\nexport class Slave {\n  private _onReadable = new EventEmitter<void>();\n  readonly onReadable = this._onReadable.register;\n\n  private _onWritable = new EventEmitter<void>();\n  readonly onWritable = this._onWritable.register;\n\n  private _onSignal = new EventEmitter<Signal>();\n  readonly onSignal = this._onSignal.register;\n\n  private fromLdiscToUpperBuffer: number[] = [];\n  private fromUpperToLdiscBuffer: number[] = [];\n\n  private winsize: [number, number] = [80, 24];\n\n  constructor(private ldisc: LineDiscipline) {\n    this.ldisc.onWriteToUpper((buf) => {\n      this.fromLdiscToUpperBuffer.push(...buf);\n      this._onReadable.fire();\n    });\n\n    this.ldisc.onFlowActivated(() => {\n      if (this.fromUpperToLdiscBuffer.length >= 1) {\n        this.ldisc.writeFromUpper(this.fromUpperToLdiscBuffer);\n        this.fromUpperToLdiscBuffer.length = 0;\n      }\n    });\n\n    this.ldisc.onSignalToUpper((sig) => {\n      this._onSignal.fire(sig);\n    });\n  }\n\n  initFromMaster() {\n    return {\n      notifyWritable: () => this._onWritable.fire(),\n      notifyResize: (rows: number, cols: number) => {\n        this.winsize = [cols, rows];\n        this._onSignal.fire(\"SIGWINCH\");\n      },\n    };\n  }\n\n  get readable() {\n    return this.fromLdiscToUpperBuffer.length >= 1;\n  }\n\n  read(length?: number) {\n    const len =\n      typeof length !== \"undefined\"\n        ? Math.min(this.fromLdiscToUpperBuffer.length, length)\n        : this.fromLdiscToUpperBuffer.length;\n    return this.fromLdiscToUpperBuffer.splice(0, len);\n  }\n\n  get writable() {\n    return this.fromUpperToLdiscBuffer.length <= bufferLimit;\n  }\n\n  write(arg: string | number[]) {\n    const buf = typeof arg == \"string\" ? stringToUtf8Bytes(arg) : arg;\n    this.fromUpperToLdiscBuffer = this.fromUpperToLdiscBuffer.concat(buf);\n\n    if (this.ldisc.flow) {\n      this.ldisc.writeFromUpper(this.fromUpperToLdiscBuffer);\n      this.fromUpperToLdiscBuffer.length = 0;\n    }\n  }\n\n  ioctl(req: \"TCGETS\"): Termios;\n  ioctl(req: \"TCSETS\", arg: TermiosConfig): void;\n  ioctl(req: \"TIOCGWINSZ\"): [number, number];\n  ioctl(req: \"TCGETS\" | \"TCSETS\" | \"TIOCGWINSZ\", arg?: any) {\n    switch (req) {\n      case \"TCGETS\":\n        return this.ldisc.termios.clone();\n      case \"TCSETS\":\n        this.ldisc.termios = Termios.fromConfig(arg);\n        return;\n      case \"TIOCGWINSZ\":\n        return this.winsize.slice();\n    }\n  }\n}\n\nexport const openpty = () => {\n  const ldisc = new LineDiscipline();\n  const slave = new Slave(ldisc);\n  const master = new Master(ldisc, slave);\n  return { master, slave };\n};\n","import { Termios } from \"../termios\";\n\n// Request types from a emscripten'ed process\nexport type TtyRequest =\n  | { ttyRequestType: \"read\"; length: number }\n  | { ttyRequestType: \"write\"; buf: number[] }\n  | { ttyRequestType: \"input\" }\n  | { ttyRequestType: \"output\"; char: number }\n  | { ttyRequestType: \"poll\"; timeout: number }\n  | { ttyRequestType: \"tcgets\" }\n  | { ttyRequestType: \"tcsets\"; data: number[] }\n  | { ttyRequestType: \"tiocgwinsz\" };\n\nexport const termiosToData = (termios: Termios) => {\n\tconst data = [termios.iflag, termios.oflag, termios.cflag, termios.lflag];\n\tlet word = 0;\n\tlet offset = 8;\n\tfor (let i = 0; i < termios.cc.length; i++) {\n\t  word |= termios.cc[i] << offset;\n\t  offset += 8;\n\t  if (offset == 32) {\n\t\tdata.push(word);\n\t\tword = 0;\n\t\toffset = 0;\n\t  }\n\t}\n\tdata.push(word);\n\treturn data;\n  };\n\n  export const dataToTermios = (data: number[]): Termios => {\n\tconst cc: number[] = [];\n\tlet ptr = 4;\n\tlet word = data[ptr++];\n\tlet offset = 8;\n\tfor (let i = 0; i < 32; i++) {\n\t  cc.push((word >> offset) & 0xff);\n\t  offset += 8;\n\t  if (offset >= 32) {\n\t\tword = data[ptr++];\n\t\toffset = 0;\n\t  }\n\t}\n\treturn new Termios(data[0], data[1], data[2], data[3], cc);\n  };\n","// This module provides a \"TtyClient\" class.\n//\n// This code runs in a Web Worker thread.\n// It sends TTY requests to TtyServer that works in the main thread.\n// The communication is based on Worker.postmessage and SharedArrayBuffer.\n\nimport { Termios } from \"../termios\";\nimport { TtyRequest, dataToTermios, termiosToData } from \"./termiosData\";\n\nexport class TtyClient {\n  private streamCtrl: Int32Array;\n  private streamData: Int32Array;\n\n  constructor(shared: SharedArrayBuffer) {\n    this.streamCtrl = new Int32Array(shared, 0, 1);\n    this.streamData = new Int32Array(shared, 4);\n  }\n\n  private req(r: TtyRequest) {\n    this.streamCtrl[0] = 0;\n    self.postMessage(r);\n    Atomics.wait(this.streamCtrl, 0, 0);\n  }\n\n  onRead(length: number | undefined) {\n    if (!length) length = this.streamData.length - 1;\n    this.req({ ttyRequestType: \"read\", length });\n    const len = this.streamData[0];\n    return Array.from(this.streamData.slice(1, len + 1));\n  }\n\n  onWrite(buf: number[]) {\n    this.req({ ttyRequestType: \"write\", buf });\n  }\n\n  onWaitForReadable(timeout: number) {\n    this.req({ ttyRequestType: \"poll\", timeout });\n    return this.streamData[0] == 1;\n  }\n\n  onIoctlTcgets() {\n    this.req({ ttyRequestType: \"tcgets\" });\n    return dataToTermios(Array.from(this.streamData.slice(0, 13)));\n  }\n\n  onIoctlTcsets(termios: Termios) {\n    const data = termiosToData(termios);\n    this.req({ ttyRequestType: \"tcsets\", data });\n  }\n\n  onIoctlTiocgwinsz() {\n    this.req({ ttyRequestType: \"tiocgwinsz\" });\n    return [this.streamData[0], this.streamData[1]];\n  }\n}\n","// This module provides a \"TtyServer\" class.\n//\n// This code runs in the main thread.\n// It accepts TTY requests from TtyClient that works in a Web Worker.\n// The communication is based on Worker.postmessage and SharedArrayBuffer.\n\nimport { Slave } from \"../pty\";\nimport { TtyRequest, dataToTermios, termiosToData } from \"./termiosData\";\n\ntype State = \"idle\" | \"input\" | \"poll\";\n\n// UI thread side\nexport class TtyServer {\n  private shared = new SharedArrayBuffer(4 + 256);\n  private streamCtrl = new Int32Array(this.shared, 0, 1);\n  private streamData = new Int32Array(this.shared, 4);\n\n  private state: State = \"idle\";\n  private timeoutHandler: NodeJS.Timeout | null = null;\n\n  ack() {\n    Atomics.store(this.streamCtrl, 0, 1);\n    Atomics.notify(this.streamCtrl, 0);\n    this.state = \"idle\";\n  }\n\n  fromWorkerBuf: number[] = [];\n  toWorkerBuf: number[] = [];\n\n  constructor(private slave: Slave) {\n    slave.onWritable(() => {\n      if (this.fromWorkerBuf.length >= 1) this.feedFromWorker();\n    });\n\n    slave.onReadable(() => {\n      this.toWorkerBuf.push(...slave.read());\n\n      switch (this.state) {\n        case \"poll\":\n          this.waitForReadable(0);\n          break;\n        case \"input\":\n          this.feedToWorker(this.toWorkerBuf.length);\n          break;\n      }\n    });\n\n    slave.onSignal((sig) => {\n      console.info(`A signal ${sig} is currently ignored`);\n      // TODO: send a signal to the Emscripten'ed process\n    });\n  }\n\n  feedToWorker(length: number) {\n    if (this.state != \"input\") throw \"worker does not wait for input\";\n    if (length > this.streamData.length - 1)\n      length = this.streamData.length - 1;\n    const buf = this.toWorkerBuf.splice(0, length);\n    this.streamData[0] = buf.length;\n    this.streamData.set(buf, 1);\n    this.ack();\n  }\n\n  feedFromWorker() {\n    if (this.fromWorkerBuf.length == 0) throw \"worker does not wait for output\";\n    if (this.slave.writable) {\n      this.ack();\n      this.slave.write(this.fromWorkerBuf.splice(0));\n    }\n  }\n\n  waitForReadable(timeout: number) {\n    if (this.state != \"poll\") throw \"worker does not wait for poll\";\n\n    if (this.timeoutHandler) {\n      clearTimeout(this.timeoutHandler);\n      this.timeoutHandler = null;\n    }\n\n    if (this.toWorkerBuf.length > 0) {\n      this.streamData[0] = 1; // ready for reading\n      this.ack();\n    } else {\n      if (timeout < 0) {\n        // block indefinitely\n      } else if (timeout > 0) {\n        // block with timeout\n        this.timeoutHandler = setTimeout(\n          () => this.waitForReadable(0),\n          timeout * 1000\n        );\n      } else {\n        this.streamData[0] = 2; // timeout\n        this.ack();\n      }\n    }\n  }\n\n  private stop_: (() => void) | null = null;\n\n  start(worker: Worker, callback?: (ev: MessageEvent<any>) => void) {\n    this.stop();\n    let stop = false;\n    this.stop_ = () => (stop = true);\n\n    worker.onmessage = (ev: MessageEvent<any>) => {\n      const req_ = ev.data;\n\n      if (typeof req_ == \"object\" && req_.ttyRequestType) {\n        if (stop) return;\n\n        const req: TtyRequest = req_;\n\n        //console.debug(req);\n\n        switch (req.ttyRequestType) {\n          case \"read\":\n            this.state = \"input\";\n            if (this.toWorkerBuf.length >= 1) this.feedToWorker(req.length);\n            break;\n          case \"write\":\n            this.fromWorkerBuf.push(...req.buf);\n            this.feedFromWorker();\n            break;\n          case \"poll\":\n            this.state = \"poll\";\n            this.waitForReadable(req.timeout);\n            break;\n          case \"tcgets\":\n            this.streamData.set(termiosToData(this.slave.ioctl(\"TCGETS\")));\n            this.ack();\n            break;\n          case \"tcsets\":\n            this.slave.ioctl(\"TCSETS\", dataToTermios(req.data));\n            this.ack();\n            break;\n          case \"tiocgwinsz\": {\n            const [rows, cols] = this.slave.ioctl(\"TIOCGWINSZ\");\n            this.streamData[0] = rows;\n            this.streamData[1] = cols;\n            this.ack();\n            break;\n          }\n        }\n      } else if (callback) {\n        callback(ev);\n      }\n    };\n\n    // kick the Web Worker\n    worker.postMessage(this.shared);\n  }\n\n  stop() {\n    if (this.stop_) this.stop_();\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","a","i","self","Object","defineProperty","value","EventEmitter","listeners","Set","register","this","_register","bind","listener","add","dispose","delete","fire","arg","e","console","error","NL","isalnum","c","iscntrl","isUtf8ContinuationByte","tolower","toupper","utf8Encoder","TextEncoder","stringToUtf8Bytes","str","Array","from","encode","Flags","Termios","constructor","iflag","oflag","cflag","lflag","cc","ISTRIP_P","INLCR_P","IGNCR_P","ICRNL_P","IUCLC_P","IXON_P","IXANY_P","IUTF8_P","OPOST_P","OLCUC_P","ONLCR_P","OCRNL_P","ONOCR_P","ONLRET_P","TABDLY_XTABS_P","ISIG_P","ICANON_P","ECHO_P","ECHOE_P","ECHOK_P","ECHONL_P","NOFLSH_P","ECHOCTL_P","ECHOPRT_P","ECHOKE_P","IEXTEN_P","INTR_V","QUIT_V","ERASE_V","KILL_V","EOF_V","TIME_V","MIN_V","SWTCH_V","START_V","STOP_V","SUSP_V","EOL_V","REPRINT_V","DISCARD_V","WERASE_V","LNEXT_V","EOL2_V","fromConfig","config","clone","defaultTermios","LineDiscipline","_onWriteToLower","onWriteToLower","_onWriteToUpper","onWriteToUpper","_onSignalToUpper","onSignalToUpper","_onFlowActivated","onFlowActivated","_onFlowDeactivated","onFlowDeactivated","T","keyActions","fill","flowActivated","column","baseColumn","vlnext","echoprt","toLowerBuf","toUpperBuf","termios","activateFlow","deactivateFlow","flow","flushToLower","clearToLower","length","outputToLower","buf","push","updateBaseColumn","clearToUpper","flushToUpper","outputToUpper","outputToLowerWithPostprocess","spaces","echoToLower","chars","raw","inputFromLowerWithPreprocess","finishECHOPRT","erase","type","alnumsFound","idx","removedChar","splice","startECHOPRT","count","tabFound","Math","max","signal","sig","checkStartFlow","nextLiteral","reprint","writeFromLower","keyAction","writeFromUpper","Master","ldisc","slave","disposables","_onWrite","onWrite","fromLdiscToLowerBuffer","waitingForLower","Uint8Array","notifyWritable","notifyResize","initFromMaster","activate","xterm","callback","write","onData","onBinary","onResize","cols","rows","forEach","d","Slave","_onReadable","onReadable","_onWritable","onWritable","_onSignal","onSignal","fromLdiscToUpperBuffer","fromUpperToLdiscBuffer","winsize","readable","read","len","min","writable","concat","ioctl","req","slice","termiosToData","data","word","offset","dataToTermios","ptr","TtyClient","shared","streamCtrl","Int32Array","streamData","r","postMessage","Atomics","wait","onRead","ttyRequestType","onWaitForReadable","timeout","onIoctlTcgets","onIoctlTcsets","onIoctlTiocgwinsz","TtyServer","SharedArrayBuffer","state","timeoutHandler","fromWorkerBuf","toWorkerBuf","stop_","feedFromWorker","waitForReadable","feedToWorker","info","ack","store","notify","set","clearTimeout","setTimeout","start","worker","stop","onmessage","ev","req_","openpty","master"],"sourceRoot":""}